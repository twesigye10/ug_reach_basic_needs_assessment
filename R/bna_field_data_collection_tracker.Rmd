---
title: "BNA: Data Collection Tracker"
author: "REACH"
date: "01/04/2022"
output:  
  html_document:
    toc: true
    toc_float:
      collapsed: false
      smooth_scroll: false
knit: (function(inputFile, encoding) { rmarkdown::render(inputFile, encoding = encoding, output_file = paste0(dirname(inputFile), '/bna_field_data_collection_tracker_', format(Sys.Date(), '%Y_%m_%d'),'.html')) })
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = F, message = F)

# read packages
library(tidyverse)
library(lubridate)
library(glue)
library(leaflet)

# read data
df_sample_breakdown <- readr::read_csv(df_sample_breakdown, file = "../outputs/sample_breakdown.csv")

df_tool_data <- readxl::read_excel(path = "../inputs/BNA_data.xlsx") %>% 
  mutate(uuid = `_uuid`,
         start_date = as_date(start),
         start = as_datetime(start),
         end = as_datetime(end),
         latitude = as.numeric(`_geopoint_latitude`),
         longitude = as.numeric(`_geopoint_longitude`))

# days that contain data
df_days_for_data_collection <- df_tool_data %>% select(start_date) %>% unique() %>% arrange(start_date) %>% pull()

df_data_support_cl_log <- df_tool_data %>% 
  select(uuid, location, latitude,	longitude )
# cleaning log handling
df_cl_log <- read_csv(file = "../inputs/combined_checks_bna.csv") %>% 
  mutate(adjust_log = ifelse(is.na(adjust_log), "apply_suggested_change", adjust_log)) %>% 
  left_join(df_data_support_cl_log, by = "uuid")

# change_response logs that affect stats in the data collection progress
cl_log_change_response <- df_cl_log %>% 
  filter(type == "change_response", 
         !is.na(value),
         reviewed == 1, 
         adjust_log != "delete_log", 
        ) %>% 
  select(uuid, name, value)

# updated tool data
df_updated_tool_data <- df_tool_data

# get uuids from cleaning log
uuids_chg_response <- cl_log_change_response %>% pull(uuid) %>% unique()

for (current_uuid in uuids_chg_response) {
  current_uuid_data <- cl_log_change_response %>% 
    filter(uuid == current_uuid) %>% 
    mutate(value = ifelse(name == "enumerator_id", as.numeric(value), value)) %>% 
    pivot_wider(names_from = "name", values_from = "value", uuid)
  print(current_uuid_data)
  # process current updates
  df_current_updated <- df_updated_tool_data %>% 
    rows_update(y = current_uuid_data, by = "uuid")
  # update the parent dataset with current updates
  df_updated_tool_data <- df_current_updated
}

# enumerator performance data
df_enum_performance <- df_updated_tool_data %>% 
  mutate(int.survey_time_interval = lubridate::time_length(end - start, unit = "min"),
         int.survey_time_interval = ceiling(int.survey_time_interval))

```

